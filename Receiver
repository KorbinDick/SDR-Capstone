#include <Arduino.h>
#include <AudioTools.h>
#include <si5351.h>
#include <Wire.h>
#include <codec2.h>
#include <math.h>
#include <stdint.h>

//setting up ESP32-WROOM-32 pins
#define BUTTON 13
#define I2S_BCLK 26
#define I2S_LRCLK 25
#define I2S_DIN 27
#define I2S_DOUT 14
#define I2S_MCLK 0

//configured system specifications
const int BITS_PER_SAMPLE = 24;
const int IN_SR = 48000;
//buffer size in samples
const int DMA_TX_RX_SIZE = 64;
//number of frames, each containing a left and right sample
const int DMA_TX_RX_FRAME = 32;
const int DMA_COUNT = 8;
//only need one channel!
//effects I2S rate (48kHz)(1)(24 bits) = half of the 
const int NUMBER_OF_CHANNELS = 1;
bool isIdle = true;

//setting up framing output information
#define IDLE_GAP_BITS 0
#define PREAMBLE_FLAGS 1
#define POSTAMBLE_FLAGS 0
const uint8_t PREAMBLE_FLAG = 0x7E;
const uint8_t POSTAMBLE_FLAG = 0x7E;

#define PCM_QUEUE_LEN 8192
QueueHandle_t pcmQueue = NULL;  
#define TX_FRAME_BITS (IDLE_GAP_BITS + (8*PREAMBLE_FLAGS) + (C2_BITS) + (8*POSTAMBLE_FLAGS))
#define TX_FRAME_BYTES ((TX_FRAME_BITS) / 8)

QueueHandle_t frameQueue = NULL;

//Codec2 uses 160 input samples every 20ms to encode the samples into 48 bits (2400 mode)
const int C2_FRAME_SAMPLES = 160;
const int C2_BITS = 48;
struct CODEC2 *c2 = nullptr;

int16_t codec_accum[C2_FRAME_SAMPLES];

const float MARK_FREQ  = 9600.0f;
const float SPACE_FREQ = 4800.0f;
const uint32_t SYMBOL_RATE = 4800;
const uint32_t PHASE_BITS = 32;
uint32_t phaseStepMark = 0;
uint32_t phaseStepSpace = 0;
volatile uint32_t currentStep = 0;

I2SStream i2sStream;
Si5351 si5351;

//see setup
bool currentBit = 0;
uint32_t samplesPerSymbol;
uint32_t samplesLeftThisSymbol;

#define TABLE_SIZE 4096
int32_t sineTable[TABLE_SIZE];
const float MARK_FREQ  = 9600.0f;
const float SPACE_FREQ = 4800.0f;
const uint32_t SYMBOL_RATE = 4800;
uint32_t phaseSpace = 0;
uint32_t phaseMark = 0;
const uint32_t PHASE_BITS = 32;
uint32_t phaseStepMark = 0;
uint32_t phaseStepSpace = 0;
volatile uint32_t currentStep = 0;
const uint32_t QUARTER_PHASE = (uint32_t)(1ULL << (PHASE_BITS - 2));

//calculates phase increment for certain frequency (4.8kHz and 9.6kHz)
uint32_t phaseIncrement(float freq) {
    return (uint32_t)((freq * (1ULL << PHASE_BITS)) / IN_SR);
}

//sets up 24 bit PCM LUT to be indexed by phase increment to synthesize analog tones
void createSineTable() {
    const float amp24 = 8388607.0f;
    for (int i = 0; i < TABLE_SIZE; ++i) {
        float angle = 2.0f * PI * (float)i / (float)TABLE_SIZE;
        sineTable[i] = (int32_t)(sin(angle) * amp24);
    }
}

//I2S setup, MCLK multiple actually turns out to be 384 due to bug known in git repo, spoke to owner about doubling, resolved
void startI2S() {
    auto config = i2sStream.defaultConfig(RXTX_MODE);
    config.sample_rate = IN_SR;
    config.bits_per_sample = BITS_PER_SAMPLE;
    config.channels = NUMBER_OF_CHANNELS;
    config.i2s_format = I2S_STD_FORMAT;
    config.buffer_count = DMA_COUNT;
    config.buffer_size = DMA_TX_RX_SIZE;
    config.is_master = true;
    config.port_no = 0;
    config.pin_ws = I2S_LRCLK;
    config.pin_bck = I2S_BCLK;
    config.pin_data = I2S_DOUT;
    config.pin_data_rx = I2S_DIN;
    config.pin_mck = I2S_MCLK;
    config.use_apll = true;
    config.mclk_multiple = I2S_MCLK_MULTIPLE_192;
    i2sStream.begin(config);
}

void rxTask(void *pvParameters) {
    (void)pvParameters;

    //64*4 = 256 bytes per I2S read,
    size_t bytesNeeded = DMA_TX_RX_SIZE * sizeof(int32_t);

    uint8_t rxByte = 0;
    uint8_t bitCount = 0;
    uint8_t sampleCount = 0;
    bool PREAMBLE_RECEIVED = false;


    while (1) {

            if(!digitalRead(BUTTON)){
                int16_t dump1;
                    while (xQueueReceive(pcmQueue, &dump1, 0) == pdTRUE){}
                vTaskDelay(pdMS_TO_TICKS(5));
                continue;
            }

        int32_t inBuf[DMA_TX_RX_SIZE];
        
        int bytesRead = i2sStream.readBytes((uint8_t*)inBuf, bytesNeeded);
        

        for (int f = 0; f < DMA_TX_RX_FRAME; f++) {

            int32_t sample = inBuf[2*f] >> 8;

            int32_t sSpace = sineTable[(phaseSpace >> (PHASE_BITS - 12)) & 0xFFF];
            int32_t sMark = sineTable[(phaseMark  >> (PHASE_BITS - 12)) & 0xFFF];


            accSpace += (int64_t)sample * sSpace;
            accMark += (int64_t)sample * sMark;

            phaseSpace += phaseStepSpace;
            phaseMark += phaseStepMark;

            sampleCount++;

            if (sampleCount >= SAMPLES_PER_SYMBOL) {

                int bit = (accMark > accSpace);

                accSpace = 0;
                accMark = 0;
                sampleCount = 0;

                // Do something with bit
                // e.g. push to queue, shift into byte, etc.
                // xQueueSend(bitQueue, &bit, 0);
                rxByte = (rxByte << 1) | (bit & 1);
                 bitCount++;

                if (bitCount == 8) {
                // rxByte is now complete
                if(rxByte == 0x7E){
                    PREAMBLE_RECEIVED = true;
                }

                rxByte = 0;
                bitCount = 0;

                
            }
        }
    }
}

void codec2Task(void *pvParameters) {
    (void)pvParameters;

    c2 = codec2_create(CODEC2_MODE_2400);
    if (!c2) {
        Serial.println("codec2_create FAILED");
        while (1) vTaskDelay(pdMS_TO_TICKS(1000));
    }

  
    while (1) {


        if (xQueueReceive(pcmQueue, &sample, pdMS_TO_TICKS(200)) == pdTRUE) {

            codec_accum[fill++] = sample;

            if (fill >= C2_FRAME_SAMPLES) {

                uint8_t enc[6];
                memset(enc, 0, sizeof(enc));

                codec2_decode(c2, enc, codec_accum);

               

               

                const TickType_t pushTimeout = pdMS_TO_TICKS(5);
                if (xQueueSend(frameQueue, frame, pushTimeout) != pdTRUE) {
                    fifoPushFailCount++;
                }
                fill = 0;
            }

        } else {
            taskYIELD();
        }
    }
}


void txTask(void *pvParameters) {
    (void)pvParameters;

    int32_t outBuf[DMA_TX_RX_SIZE];

    uint8_t frame[TX_FRAME_BYTES];
    uint16_t bitIndex = 0;
    const uint16_t totalBits = TX_FRAME_BITS;

    bool usingIdle = true;

    samplesLeftThisSymbol = samplesPerSymbol;
    currentStep = phaseStepSpace;

    while (1) {

        for (int i = 0; i < DMA_TX_RX_FRAME; i++) {

        }


            


        size_t wrote = i2sStream.write((uint8_t*)outBuf, DMA_TX_RX_SIZE * sizeof(int32_t));
    }
}


void setup() {

    Serial.begin(115200);
    //SDA-21 SCL-22
    Wire.begin(21, 22);
    si5351.init(SI5351_CRYSTAL_LOAD_8PF, 25000000, 0);
    si5351.set_freq_manual(103000000ULL * 100, SI5351_PLL_FIXED, SI5351_CLK0);
    si5351.drive_strength(SI5351_CLK0, SI5351_DRIVE_8MA);
    si5351.output_enable(SI5351_CLK0, 1);

    pinMode(BUTTON, INPUT_PULLDOWN);

    createSineTable();
    phaseStepMark = phaseIncrement(MARK_FREQ);
    phaseStepSpace = phaseIncrement(SPACE_FREQ);

    samplesPerSymbol = IN_SR / SYMBOL_RATE;
    samplesLeftThisSymbol = samplesPerSymbol;

    startI2S();
    frameQueue = xQueueCreate(16, TX_FRAME_BYTES); 


    xTaskCreatePinnedToCore(rxTask, "rxTask", 8192, NULL, 5, NULL, 0);
    xTaskCreatePinnedToCore(codec2Task, "codec2Task", 16384, NULL, 4, NULL, 1);
    xTaskCreatePinnedToCore(txTask, "txTask", 8192, NULL, 4, NULL, 0);
}

void loop() {

    vTaskDelay(pdMS_TO_TICKS(1000));
    //Serial.printf("FIR=%d nextBit=%d frameQ=%u\n", lastFirOut, lastNextBit, (unsigned)uxQueueMessagesWaiting(frameQueue));
    //Serial.printf("Frames=%u pushFail=%u pcmDrops=%u idling=%d\n", encodedFrames, fifoPushFailCount, pcmQueueDrops, isIdle);
    
    if(digitalRead(BUTTON)){
      Serial.printf("Button Pushed!\n");
    }


    }
